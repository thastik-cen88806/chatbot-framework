// Generated using Sourcery 1.0.2 â€” https://github.com/krzysztofzablocki/Sourcery
// DO NOT EDIT

// swiftlint:disable file_length

/// handles optional enum comparison
///
/// - Parameters:
///   - lhs: left optional value
///   - rhs: right optional value
///   - compare: comparison function
/// - Returns: bool of the outcome
///
/// - Warning: do not edit - this file is autogenerated with every build
///                          from a stencil file by sourcery framework
///
fileprivate func compareOptionals<T>(lhs: T?,
                                     rhs: T?,
                                     compare: (_ lhs: T, _ rhs: T) -> Bool) -> Bool {

    switch (lhs, rhs) {

        case let (lValue?, rValue?): return compare(lValue, rValue)

        case (nil, nil): return true

        default: return false
    }
}

/// handles array comparison
///
/// - Parameters:
///   - lhs: left array value
///   - rhs: right array value
///   - compare: comparison function
/// - Returns: bool of the outcome
///
/// - Warning: do not edit - this file is autogenerated with every build
///                          from a stencil file by sourcery framework
///
fileprivate func compareArrays<T>(lhs: [T],
                                  rhs: [T],
                                  compare: (_ lhs: T, _ rhs: T) -> Bool) -> Bool {

    guard lhs.count == rhs.count else { return false }

    for (idx, lhsItem) in lhs.enumerated() {

        guard compare(lhsItem, rhs[idx]) else { return false }
    }

    return true
}


// MARK: - AutoEquatable CBError

extension CBError: Equatable {}

/// function handling comparison of the enum cases
///
/// - Parameters:
///   - lhs: left enum value
///   - rhs: right enum value
/// - Returns: bool outcome of the operation
///
/// - Warning: do not edit - this file is autogenerated with every build
///                          from a stencil file by sourcery framework
///
public func == (lhs: CBError, rhs: CBError) -> Bool {

    switch (lhs, rhs) {

        case (.arrayElementsOverflow(let lhs), .arrayElementsOverflow(let rhs)):
            return lhs == rhs

        case (.invalidUri(let lhs), .invalidUri(let rhs)):
            return lhs == rhs

        case (.networkTimeout(let lhs), .networkTimeout(let rhs)):
            return lhs == rhs

        case (.textLengthOverflow(let lhs), .textLengthOverflow(let rhs)):
            return lhs == rhs

        case (.tokenZeroDecode(let lhs), .tokenZeroDecode(let rhs)):
            return lhs == rhs

        case (.tokenZeroHTMLExtract(let lhs), .tokenZeroHTMLExtract(let rhs)):
            return lhs == rhs

        case (.tokenZeroDataDecoding(let lhs), .tokenZeroDataDecoding(let rhs)):
            return lhs == rhs

        case (.tokenZeroNoHTMLData, .tokenZeroNoHTMLData):
            return true

        case (.tokenJWTExpired, .tokenJWTExpired):
            return true

        case (.regexFormat(let lhs), .regexFormat(let rhs)):
            return lhs == rhs

        case (.regexNoMatch(let lhs), .regexNoMatch(let rhs)):
            return lhs == rhs

        default: return false
    }
}
// MARK: - AutoEquatable ChatMessage

extension ChatMessage: Equatable {}

/// function handling comparison of the enum cases
///
/// - Parameters:
///   - lhs: left enum value
///   - rhs: right enum value
/// - Returns: bool outcome of the operation
///
/// - Warning: do not edit - this file is autogenerated with every build
///                          from a stencil file by sourcery framework
///
public func == (lhs: ChatMessage, rhs: ChatMessage) -> Bool {

    switch (lhs, rhs) {

        case (.`init`(let lhs), .`init`(let rhs)):
            return lhs == rhs

        case (.start(let lhs), .start(let rhs)):
            return lhs == rhs

        case (.pong(let lhs), .pong(let rhs)):
            return lhs == rhs

        case (.typing(let lhs), .typing(let rhs)):
            return lhs == rhs

        case (.message(let lhs), .message(let rhs)):
            return lhs == rhs

        case (.quickReply(let lhs), .quickReply(let rhs)):
            return lhs == rhs

        case (.unknown, .unknown):
            return true

        default: return false
    }
}

extension App: Equatable {}

public func == (lhs: App, rhs: App) -> Bool {
    guard lhs.id == rhs.id else { return false }
    guard lhs.webhook == rhs.webhook else { return false }
    guard compareOptionals(lhs: lhs.messages, rhs: rhs.messages, compare: ==) else { return false }
    guard compareOptionals(lhs: lhs.msgPostbacks, rhs: rhs.msgPostbacks, compare: ==) else { return false }
    guard compareOptionals(lhs: lhs.standby, rhs: rhs.standby, compare: ==) else { return false }
    guard compareOptionals(lhs: lhs.msgHandovers, rhs: rhs.msgHandovers, compare: ==) else { return false }
    guard compareOptionals(lhs: lhs.typing, rhs: rhs.typing, compare: ==) else { return false }
    guard compareOptionals(lhs: lhs.readDelivery, rhs: rhs.readDelivery, compare: ==) else { return false }
    guard compareOptionals(lhs: lhs.parentAppid, rhs: rhs.parentAppid, compare: ==) else { return false }
    guard compareOptionals(lhs: lhs.sharedContextUpdate, rhs: rhs.sharedContextUpdate, compare: ==) else { return false }
return true
}
extension Channel: Equatable {}

public func == (lhs: Channel, rhs: Channel) -> Bool {
    guard lhs.id == rhs.id else { return false }
    guard compareOptionals(lhs: lhs.getStarted, rhs: rhs.getStarted, compare: ==) else { return false }
    guard compareOptionals(lhs: lhs.receiverAppId, rhs: rhs.receiverAppId, compare: ==) else { return false }
    guard compareOptionals(lhs: lhs.cookieDomain, rhs: rhs.cookieDomain, compare: ==) else { return false }
    guard compareOptionals(lhs: lhs.whitelistedOrigins, rhs: rhs.whitelistedOrigins, compare: ==) else { return false }
return true
}
extension ChannelPayload: Equatable {}

public func == (lhs: ChannelPayload, rhs: ChannelPayload) -> Bool {
    guard lhs.payload == rhs.payload else { return false }
return true
}
extension Identity: Equatable {}

public func == (lhs: Identity, rhs: Identity) -> Bool {
    guard lhs.id == rhs.id else { return false }
    guard lhs.name == rhs.name else { return false }
    guard lhs.profileImg == rhs.profileImg else { return false }
return true
}
extension Init: Equatable {}

public func == (lhs: Init, rhs: Init) -> Bool {
    guard lhs.`init` == rhs.`init` else { return false }
    guard lhs.sender == rhs.sender else { return false }
    guard lhs.recipient == rhs.recipient else { return false }
return true
}
extension Persona: Equatable {}

public func == (lhs: Persona, rhs: Persona) -> Bool {
    guard lhs.name == rhs.name else { return false }
    guard lhs.profileImg == rhs.profileImg else { return false }
return true
}
extension Pong: Equatable {}

public func == (lhs: Pong, rhs: Pong) -> Bool {
    guard lhs.ping == rhs.ping else { return false }
    guard lhs.pong == rhs.pong else { return false }
return true
}
extension Postback: Equatable {}

public func == (lhs: Postback, rhs: Postback) -> Bool {
    guard lhs.payload == rhs.payload else { return false }
    guard compareOptionals(lhs: lhs.appId, rhs: rhs.appId, compare: ==) else { return false }
return true
}
extension QuickReply: Equatable {}

public func == (lhs: QuickReply, rhs: QuickReply) -> Bool {
    guard lhs.contentType == rhs.contentType else { return false }
    guard lhs.title == rhs.title else { return false }
    guard compareOptionals(lhs: lhs.payload, rhs: rhs.payload, compare: ==) else { return false }
return true
}
extension QuickReplyMessage: Equatable {}

public func == (lhs: QuickReplyMessage, rhs: QuickReplyMessage) -> Bool {
    guard lhs.text == rhs.text else { return false }
    guard lhs.replies == rhs.replies else { return false }
return true
}
extension SharedContext: Equatable {}

public func == (lhs: SharedContext, rhs: SharedContext) -> Bool {
    guard compareOptionals(lhs: lhs.auth, rhs: rhs.auth, compare: ==) else { return false }
    guard compareOptionals(lhs: lhs.lang, rhs: rhs.lang, compare: ==) else { return false }
    guard compareOptionals(lhs: lhs.viewport, rhs: rhs.viewport, compare: ==) else { return false }
    guard compareOptionals(lhs: lhs.webPage, rhs: rhs.webPage, compare: ==) else { return false }
    guard lhs.webUserAgent == rhs.webUserAgent else { return false }
return true
}
extension Stamp: Equatable {}

public func == (lhs: Stamp, rhs: Stamp) -> Bool {
    guard lhs.value == rhs.value else { return false }
return true
}
extension Start: Equatable {}

public func == (lhs: Start, rhs: Start) -> Bool {
    guard lhs.messageId == rhs.messageId else { return false }
    guard lhs.postback == rhs.postback else { return false }
    guard lhs.recipient == rhs.recipient else { return false }
    guard lhs.sender == rhs.sender else { return false }
    guard lhs.context == rhs.context else { return false }
    guard lhs.timestamp == rhs.timestamp else { return false }
return true
}
extension TextMessage: Equatable {}

public func == (lhs: TextMessage, rhs: TextMessage) -> Bool {
    guard lhs.text == rhs.text else { return false }
return true
}
extension WebPage: Equatable {}

public func == (lhs: WebPage, rhs: WebPage) -> Bool {
    guard compareOptionals(lhs: lhs.ancestorOrigins, rhs: rhs.ancestorOrigins, compare: ==) else { return false }
    guard compareOptionals(lhs: lhs.hash, rhs: rhs.hash, compare: ==) else { return false }
    guard compareOptionals(lhs: lhs.host, rhs: rhs.host, compare: ==) else { return false }
    guard compareOptionals(lhs: lhs.hostname, rhs: rhs.hostname, compare: ==) else { return false }
    guard compareOptionals(lhs: lhs.href, rhs: rhs.href, compare: ==) else { return false }
    guard compareOptionals(lhs: lhs.origin, rhs: rhs.origin, compare: ==) else { return false }
    guard compareOptionals(lhs: lhs.pageTitle, rhs: rhs.pageTitle, compare: ==) else { return false }
    guard compareOptionals(lhs: lhs.pathname, rhs: rhs.pathname, compare: ==) else { return false }
    guard compareOptionals(lhs: lhs.port, rhs: rhs.port, compare: ==) else { return false }
    guard compareOptionals(lhs: lhs.`protocol`, rhs: rhs.`protocol`, compare: ==) else { return false }
    guard compareOptionals(lhs: lhs.search, rhs: rhs.search, compare: ==) else { return false }
return true
}
